## Indices

- Es una entidad
- Facilitan la busqueda (diccionario)
- Si no se agregan indices se recorre toda la tabla y todos los registros para encontrar lo que se busque
- Sin indices el costo de procesamiento es muy alto

### Caso MyISAM

- crea tabla auxiliar con el indice y su referencia
- cada vez que se genere un nuevo inidice se crea esa nueva estructura auxiliar.
- Si existe una modificacion en la tabla original entonces todos los indices se actualizan
- Si existen muchos indices entonces mas es el tiempo de ejecucion


![MySAM indice id](/imagenes/clase02/myisam_indice_id.png)

![MyISAM indice titulo](/imagenes/clase02/myisam_indice_titulo.png)

![MyISAM indice autor](/imagenes/clase02/myisam_indice_autor.png)

### Caso InnoDB

- Existe una clave primaria
- La llave primaria ya esta ordenada e indexada facilitando las consultas y su velocidad
- La tabla esta ordenada automaticamente con la clave primaria
- Mejor desempeño ya que todos se busca usando la llave primaria
- Costo para hallar registro de campo que no es PK en innoDB es igual a MyISAM

![InnoDB PK + indice titulo ](/imagenes/clase02/innodb_pk_titulo.png)

![InnoDB PK + indice autor](/imagenes/clase02/innodb_pk_autor.png)


¿Cómo podría perjudicar a una base de datos el hecho de que una tabla contenga muchos índices?

- Muchos índices harán que los comandos de INSERT, UPDATE y DELETE se vuelvan más lentos.
- Como los índices deben ser reconstruidos cada vez que se modifican los datos de las tablas, muchos índices sí afectan el desempeño
  

## MyISAM - Algoritmo del Indice

- Crea una estructura separada para los inidces PK y no PK
- La columna de inidces es ordenada y toma como referencia la posicion de la fila de la tabla original
- Implementa indices HASH y BTREE


## InnoDB - Algoritmo del Indice

- La tabla original ya esta ordenada con la PK
- Los indices que no son PK poseen estructuras separadas y toman como referencia el valor de la PK
- Solo trabaja con BTREE

**HASH** y **BTREE** son algoritmos de busqueda en listas ordenadas.

![Arbol Binario](/imagenes/clase02/arbol_binario.png)

![Btree Busca 33](/imagenes/clase02/btree_busca_33.png)

![Btree Balanceado](/imagenes/clase02/btree_balanceado.png)

![Btree Ejemplo 2](/imagenes/clase02/btree_ejemplo_2.png)

![Btree Busca 339](/imagenes/clase02/btree_busca_339.png)


### HASH

- Mapea datos grandes de tamaños variables en un tamaño fijo
- Cuando abrimos un libro, buscamos en el indice para encontrar la pagina que deseamos consultar
- Criptografia, almacenar contraseñas entre otros
- Usa un algoritmo matematico
- Usa Buckets
- Ejemplos:
  - asddjgdjdkhfkhghghgggafgfa..................10124242252
  - hjjhhjhshhdkjskjsj..........................84545755545
  - datsosisjkjists.............................88755545444
  - ffadsf......................................78787555110

Proceso de HASH

Paso 1:
![Hash paso 1](/imagenes/clase02/hash_p1.png)

Paso 2:
![Hash paso 2](/imagenes/clase02/hash_p2.png)

Paso 3:
![Hash paso 3](/imagenes/clase02/hash_p3.png)

### Como el indice mejora un query

Por ejemplo en el siguiente query:

```sql
    SELECT * 
    FROM credicel_alura_bd.facturas
    where FECHA_VENTA='20170101';
    -- el tiempo de consulta es .250 ms
    -- sin indice como fecha_venta
    -- da 'Last_query_cost', '17842.599000'

```

Luego si creamos la columna fecha_venta como indice:
```sql
    ALTER TABLE `credicel_alura_bd`.`facturas` 
    ADD INDEX `fecha_factura` USING BTREE (`FECHA_VENTA`) VISIBLE;
    -- luego la consulta da:
    -- baja a .234 ms no se nota mucha diferencia
    SHOW SESSION STATUS LIKE 'Last_query_cost';
    -- da 'Last_query_cost', '88.931226'
    -- no se pmuestra diferencia notable en el tiempo pero si en el costo
    SHOW WARNINGS; -- para ver si hay detalles
    -- por consola se usaria:
    EXPLAIN FORMAT=JSON SELECT * FROM FACTURAS WHERE FECHA_VENTA='20170101' \G; 
```

![Costo sin indice](/imagenes/clase02/costo_sin_indice.png)

![Costo con indice](/imagenes/clase02/costo_con_indice.png)
