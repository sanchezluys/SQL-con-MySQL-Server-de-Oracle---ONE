## Trabajando con indices y mysqlslap

- Se puede ver graficamente el costo y proceso de una query, probando en mariadb no lo puedo ver graficamente
- En la clase se crean tablas espejos de las ya existentes pero se les quita las llaves primarias y las foraneas
- Luego se ejecutan querys evaluando el plan de ejecucion y el costo, donde se observa que se eleva a billones
- Conclusion las llaves e indices mejoran enormemente el desempeño de los querys
- Cuando el table-scan se muestra verde es que esta usando un indice

![Plan Ejecucion grafico 1](/imagenes/clase03/plan_ejecucion_grafico_1.png)

![Plan ejecucion mariadb](/imagenes/clase03/plan_ejecucion_mariadb.png)

![Plan ejecucion grafico 2](/imagenes/clase03/plan_ejecucion_grafico_2.png)


### MySQLslap

- herramienta para simular diferentes consultas concurrentes a las tablas y asi poder evaluar el desempeño o comportamiento del query


Ejemplo sin indice:

![Sin indice](/imagenes/clase03/sin_indice.png)

Con indice:

![Con indice](/imagenes/clase03/con_indice.png)

Usando mysqlslap
![Usando mysqlslap por consola](/imagenes/clase03/usando_mysqlslap.png)

```dos
    mysqlslap --host=localhost --user=tu_usuario --password --concurrency=50 --iterations=10 --query="SELECT * FROM tu_tabla WHERE tu_condicion;" --create-schema=tu_base_de_datos
```

## Resumen de la Clase

```sql
    SELECT A.CODIGO_DEL_PRODUCTO FROM tabla_de_productos A;
```
![R_plan_1](/imagenes/clase03/r_plan_1.png)


```sql
    SELECT A.CODIGO_DEL_PRODUCTO, C.CANTIDAD FROM tabla_de_productos A INNER JOIN items_facturas C ON A.CODIGO_DEL_PRODUCTO = C.CODIGO_DEL_PRODUCTO;
```
![R_plan_2](/imagenes/clase03/r_plan_2.png)


```sql
    SELECT A.CODIGO_DEL_PRODUCTO, YEAR(B.FECHA_VENTA) AS ANO,C.CANTIDAD FROM tabla_de_productos A INNER JOIN items_facturas C ON A.CODIGO_DEL_PRODUCTO = C.CODIGO_DEL_PRODUCTO INNER JOIN facturas B ON C.NUMERO = B.NUMERO;
    -- El color rojo indica que no encontró un índice, entonces tuvo que hacer un scan a toda la tabla; en cambio, el color verde indica que sí encontró un índice, y el mismo, facilitó la búsqueda al interior de la tabla, reduciendo el costo de procesamiento. En este caso, el índice fue creado al momento de establecer claves primarias y foráneas en las respectivas tablas
    --
```
![R_plan_3](/imagenes/clase03/r_plan_3.png)


## Ahora pero con tablas sin indices:

```sql
    SELECT A.CODIGO_DEL_PRODUCTO, YEAR(B.FECHA_VENTA) AS ANO,C.CANTIDAD FROM tabla_de_productos1 A INNER JOIN items_facturas1 C ON A.CODIGO_DEL_PRODUCTO = C.CODIGO_DEL_PRODUCTO INNER JOIN facturas1 B ON C.NUMERO = B.NUMERO;
    -- Todos los rectángulos aparecen en rojo, el costo de procesamiento fue el más alto posible debido a que las búsquedas se realizaron sin la ayuda de índices
```
![r_sin_indice_1](/imagenes/clase03/r_sin_indice_1.png)


```dos
    mysqlslap -uroot -p --concurrency=100 --iterations=10 --create-schema=jugos_ventas --query="SELECT * FROM facturas WHERE FECHA_VENTA = '20170101'";
    -- Este es el promedio de tiempo que van a demorar 100 usuarios diferentes para obtener el resultado de la misma consulta al ejecutarla al mismo tiempo
```
![mysqlslap_1](/imagenes/clase03/mysqlslap_1.png)


```dos
    mysqlslap -uroot -p --concurrency=100 --iterations=10 --create-schema=jugos_ventas --query="SELECT * FROM facturas1 WHERE FECHA_VENTA = '20170101'";
```
![mysqlslap_2](/imagenes/clase03/mysqlslap_2.png)